find_shape_model (
Image        //搜索圖像
ModelID      //模板句柄
AngleStart   // 搜索時的起始角度
AngleExtent  //搜索時的角度範圍，必須與創建模板時的有交集
MinScore     //最小匹配值，輸出的匹配的得分Score 大于該值
NumMatches   //定義要輸出的匹配的最大個數
MaxOverlap   //當找到的目標存在重疊時，且重疊大于該值時選擇一個好的輸出
SubPixel     //計算精度的設置，五種模式，多選2，3
NumLevels    //搜索時金字塔的層數
Greediness   //貪婪度，搜索啟發式，一般都設為0.9，越高速度快,容易出現找不到的情況

Row, Column, Angle, Score ) //輸出匹配位置的行和列坐標、角度、得分。

1. Row、Column的坐標並不是模板在搜索圖像中的精確位置，因此不能直接使用他們。這些數值是為了創建變換矩陣被優化后的，你可以用這個矩陣的匹配結果完成各種任務，比如調整后續步驟的ROI。

2. Score是一個0到1之間的數，是模板在搜索圖像中可見比例的近似測量。如果模板的一半被遮擋，該值就不能超過0.5。

3. Image的domain定義了模型參考點的搜索區域，模型參考點是在create_shape_model中用來創建模型的圖像的domain區域的重心。不考慮使用函數set_shape_model_origin設置不同的初始位置。在圖像domain區域的這些點內搜索模型，其中模型完全屬於這幅圖像。這意味著如果模型超出圖像邊界，即使獲得的質量係數(score)大于MinScore也不能找到模型。這種性能可以通過set_system('border_shape_models','true')改變，這樣那些超出圖像邊界，質量係數大于MinScore的模型也能找到。這時那些在圖像外面的點看作是被遮擋了，可以降低質量係數。在這種模式下搜索的時間將要增加。

4. 參數AngleStart和AngleExtent確定了模型搜索的旋轉角度，如果有必要，旋轉的範圍會被截取成為create_shape_model函數中給定的旋轉範圍。這意味著創建模型和搜索時的角度範圍必須真正的重疊。在搜索時的角度範圍不會改變為模2*pi的。為了簡化介紹，在該段落剩下的部分所有角度都用度來表示，而在find_shape_model函數中使用弧度來設置的。因此，如果創建模板時，AngleStart=-20°、AngleExtent=40°，在搜索模板函數find_shape_model中設置AngleStart=350°、AngleExtent=20°，盡管角度模360后是重疊的，還是會找不到模板的。為了找到模板，在這個例子中必須將AngleStart=350°改為AngleStart=-10°。

5. 參數MinScore定義模板匹配時至少有個什麼樣的質量係數才算是在圖像中找到模板。MinScore設置的越大,搜索的就越快。如果模板在圖像中沒有被遮擋，MinScore可以設置為0.8這麼高甚至0.9。

6. NumMatches定義了在圖像上找到模板的最大的個數。如果匹配時的質量係數大于MinScore的目標個數多于NumMatches，僅僅返回質量係數最好的NumMatches個目標位置。如果找的匹配目標不足NumMatches，那麼就只返回找到的這幾個。參數MinScore優于NumMatches。

7. 如果模型具有對稱性，會在搜索圖像的同一位置和不同角度上找到多個與目標匹配的區域。參數MaxOverlap是0到1之間的，定義了找到的兩個目標區域最多重疊的係數，以便于把他們作為兩個不同的目標區域分別返回。如果找到的兩個目標區域彼此重疊並且大于MaxOverlap，僅僅返回效果最好的一個。重疊的計算方法是基于找到的目標區域的任意方向的最小外接矩形(看smallest_rectangle2)。如果MaxOverlap=0, 找到的目標區域不能存在重疊, 如果MaxOverla p=1，所有找到的目標區域都要返回。

8. SubPixel確定找到的目標是否使用亞像素精度提取。如果SubPixel設置為'none'(或者'false' 背景兼容)，模型的位置僅僅是一個像素精度和在create_shape_model中定義的角度分辨率。如果SubPixel設置為'interpo lation'(或'true')，位置和角度都是亞像素精度的。在這種模式下模型的位置是在質量係數函數中插入的，這種模式幾乎不花費計算時間，並且能達到足夠高的精度，被廣泛使用。然而在一些精度要求極高的應用中，模板的位置應該通過最小二乘調整決定，比如通過最小化模板點到相關圖像點的距離。與 'interpolation'相比，這種模式需要額外的計算時間。對於最小二乘調整的模式有：'least_squares', 'least_squares_high', 和'least_squares_very_high'。他們可用來定義被搜索的最小距離的精度，選擇的精度越高，亞像素提取的時間越長。然而，通常SubPixel設置為'interpolation'。如果希望設置最小二乘就選擇'least_squares'，因為這樣才能確保運行時間和精度的權衡。

9. NumLevels是在搜索時使用的金字塔層數，如有必要，層數截成創建模型時的範圍。如果NumLevels=0，使用創建模板時金字塔的層數。另外NumLevels還可以包含第二個參數，這個參數定義了找到匹配模板的最低金字塔層數。NumLevels=[4,2]表示匹配在第四層金字塔開始，在第二層金字塔找到匹配（最低的設為1）。可以使用這種方法降低匹配的運行時間，但是這種模式下位置精度是比正常模式下低的，所謂正常模式是在金字塔最底層匹配。因此如果需要較高的精度，應該設置SubPixel至少為'least_squares'。如果金字塔最底層設置的過大，可能不會達到期望的精度，或者找到一個不正確的匹配區域。這是因為在較高層的金字塔上模板是不夠具體的，不足以找到可靠的模板最佳匹配。在這種情況下最低金字塔層數應設為最小值。

10. 參數Greediness確定在搜索時的“貪婪程度”。如果Greediness=0，使用一個安全的搜索啟發式，只要模板在圖像中存在就一定能找到模板，然而這種方式下搜索是相對浪費時間的。如果Greediness=1，使用不安全的搜索啟發式，這樣即使模板存在於圖像中，也有可能找不到模板，但只是少數情況。如果設置Greediness=0.9，在幾乎所有的情況下，總能找到模型的匹配。

前面主要介紹了匹配的2個主要的算子，對這兩個算子了解后，我們就可以做匹配了。下面是轉自一位前輩的經驗總結，對我們很有幫助。
    到這裡匹配就結束了，但是我們僅僅完成了初步的工作，后面我們還要對其做一定的變換，完成實際項目的具體應用。

（轉自基于HALCON的模板匹配方法總結--藍云楊的機器視覺之路）

Shape-Based matching的基本流程

HALCON提供的基于形狀匹配的算法主要是針對感興趣的小區域來建立模板，對整個圖像建立模板也可以，但這樣除非是對象在整個圖像中所占比例很大，比如像視頻會議中人體上半身這樣的圖像，我在后面的視頻對象跟蹤實驗中就是針對整個圖像的，這往往也是要犧牲匹配速度的，這個后面再講。基本流程是這樣的，如下所示：

1. 首先確定出ROI的矩形區域，這裡只需要確定矩形的左上點和右下點的坐標即可，gen_rectangle1()這個函數就會幫助你生成一個矩形，利用area_center()找到這個矩形的中心；

2. 然後需要從圖像中獲取這個矩形區域的圖像，reduce_domain()會得到這個ROI；這之後就可以對這個矩形建立模板，而在建立模板之前，可以先對這個區域進行一些處理，方便以後的建模，比如閾值分割，數學形態學的一些處理等等；

3. 接下來就可以利用create_shape_model()來創建模板了，這個函數有許多參數，其中金字塔的級數由Numlevels指定，值越大則找到物體的時間越少，AngleStart和AngleExtent決定可能的旋轉範圍，AngleStep指定角度範圍搜索的步長；這裡需要提醒的是，在任何情況下，模板應適合主內存，搜索時間會縮短。對特別大的模板，用Optimization來減少模板點的數量是很有用的；MinConstrast將模板從圖像的噪聲中分離出來，如果灰度值的波動範圍是10，則MinConstrast應當設為10；Metric參數決定模板識別的條件，如果設為’use_polarity’，則圖像中的物體和模板必須有相同的對比度；創建好模板后，這時還需要監視模板，用inspect_shape_model()來完成，它檢查參數的適用性，還能幫助找到合適的參數；另外，還需要獲得這個模板的輪廓，用於后面的匹配，get_shape_model_contours()則會很容易的幫我們找到模板的輪廓；

4. 創建好模板后，就可以打開另一幅圖像，來進行模板匹配了。這個過程也就是在新圖像中尋找與模板匹配的圖像部分，這部分的工作就由函數find_shape_model()來承擔了，它也擁有許多的參數，這些參數都影響著尋找模板的速度和精度。這個的功能就是在一幅圖中找出最佳匹配的模板，返回一個模板實例的長、寬和旋轉角度。其中參數SubPixel決定是否精確到亞像素級，設為’interpolation’，則會精確到，這個模式不會占用太多時間，若需要更精確，則可設為’least_square’,’lease_square_high’，但這樣會增加額外的時間，因此，這需要在時間和精度上作個折中，需要和實際聯系起來。比較重要的兩個參數是MinSocre和Greediness，前一個用來分析模板的旋轉對稱和它們之間的相似度，值越大，則越相似，后一個是搜索貪婪度，這個值在很大程度上影響著搜索速度，若為0，則為啟發式搜索，很耗時，若為1，則為不安全搜索，但最快。在大多數情況下，在能夠匹配的情況下，盡可能的增大其值。

5. 找到之後，還需要對其進行轉化，使之能夠顯示，這兩個函數vector_angle_to_rigid()和affine_trans_contour_xld()在這裡就起這個作用。前一個是從一個點和角度計算一個剛體仿射變換，這個函數從匹配函數的結果中對構造一個剛體仿射變換很有用，把參考圖像變為當前圖像。

基于形狀匹配的參數關係與優化

在HALCON的說明資料里講到了這些參數的作用以及關係，在上面提到的文章中也作了介紹，這裡主要是重復說明一下這些參數的作用，再強調一下它們影響匹配速度的程度；

在為了提高速度而設置參數之前，有必要找出那些在所有測試圖像中匹配成功的設置，這時需考慮以下情況：
① 必須保證物體在圖像邊緣處截斷，也就是保證輪廓的清晰，這些可以通過形態學的一些方法來處理；
② 如果Greediness值設的太高，就找不到其中一些可見物體，這時最後將其設為0來執行完全搜索；
③ 物體是否有封閉區域，如果要求物體在任何狀態下都能被識別，則應減小MinScore值；
④ 判斷在金字塔最高級上的匹配是否失敗，可以通過find_shape_model（）減小NumLevels值來測試；
⑤ 物體是否具有較低的對比度，如果要求物體在任何狀態下都能被識別，則應減小MinContrast值；
⑥ 判斷是否全局地或者局部地轉化對比度極性，如果需要在任何狀態下都能被識別，則應給參數Metric設置一個合適的值；
⑦ 物體是否與物體的其他實例重疊，如果需要在任何狀態下都能識別物體，則應增加MaxOverlap值；
⑧ 判斷是否在相同物體上找到多個匹配值，如果物體幾乎是對稱的，則需要控制旋轉範圍；

如何加快搜索匹配，需要在這些參數中進行合理的搭配，有以下方法可以參考：
① 只要匹配成功，則盡可能增加參數MinScore的值；
② 增加Greediness值直到匹配失敗，同時在需要時減小MinScore值；
③ 如果有可能，在創建模板時使用一個大的NumLevels，即將圖像多分幾個金字塔級；
④ 限定允許的旋轉範圍和大小範圍，在調用find_shape_model（）時調整相應的參數；
⑤ 盡量限定搜索ROI的區域；

除上面介紹的以外，在保證能夠匹配的情況下，盡可能的增大Greediness的值，因為在后面的實驗中，用模板匹配進行視頻對象跟蹤的過程中，這個值在很大程度上影響到匹配的速度。
當然這些方法都需要跟實際聯系起來，不同圖像在匹配過程中也會有不同的匹配效果，在具體到某些應用，不同的硬件設施也會對這個匹配算法提出新的要求，所以需要不斷地去嘗試。